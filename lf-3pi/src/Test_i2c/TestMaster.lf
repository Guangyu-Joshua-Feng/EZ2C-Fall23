target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  threading: false,
  cmake-include: ["../../pio-lib/pio-lib.txt", "../cmake_include/i2c.txt"],
  files: ["../../pio-lib/"],
  keepalive: true
}

preamble {=
  #include <hardware/gpio.h>
  #include <hardware/i2c.h>
  #include <hardware/pio.h>
  #include <pico/stdlib.h>
  #include <pico/unique_id.h>
  #include <rise_time.h>
  #include <rise_time.pio.h>
  #include <stdio.h>
  #include <string.h>

  #define BAUD_RATE (100)             // I2C baud rate (Hz).
  #define RISE_TIME_COUNT_LIMIT 1000  // Take average number of cycles every this number of rises.
  #define RISE_TIME_CYCLES_MAX 100    // I2C maximum allowed rise time in cycles.
  #define RISE_TIME_CYCLES_MIN 50     // I2C minimum allowed rise time in cycles.
  #define INTERNAL_PULL_UP 0          // Disables (0) or enables (1) Pico's internal pull-up

  #define MAX_SLAVES 30                // Maximum supported number of I2C slave devices.
  #define I2C_DEFAULT_SLAVE_ADDR 0x55  // I2C default slave address.

  #define PICO_DEFAULT_I2C_SDA_PIN 4    // I2C SDA (data).
  #define PICO_DEFAULT_I2C_SCL_PIN 5    // I2C SCL (clock).
  #define PULLUP_DEMUX_A0_PIN 14        // Dynamic pull-up selection demux input A0.
  #define PULLUP_DEMUX_A1_PIN 15        // Dynamic pull-up selection demux input A1.
  #define PIO_LO_THRESHOLD_PIN 20       // PIO rise time measurement low threshold input pin.
  #define PIO_HI_THRESHOLD_PIN 21       // PIO rise time measurement high threshold input pin.

  #define COMMAND_DISCOVER 0  // I2C command: discover new slave devices.
  #define COMMAND_ASSIGN 1    // I2C command: assign address to new slave device.
  #define COMMAND_ECHO 2      // I2C command: send test message to slave and monitor echo.
=}

main reactor {
  preamble {=
    // I2C variables and functions.
    /** Dynamic slave address allocation steps:
     *      1. Boardcast discover command to the default slave address.
     *      2. Read response, which should contain the unique identifier of a device
     *         whose address is yet to be assigned, or fail if no device is waiting
     *         to be discovered.
     *      3. If at least one response is read, go to 4; otherwise, go to 7.
     *      4. Get the next unused slave address from table and increment slave
     *         counter.
     *      5. Send address reassignment command + unique identifier + new address
     *         to the slave. Only the slave with the right unique identifier will
     *         change their address accordingly.
     *      6. Go to 1 and restart the procedure until all slaves have their unique
     *         addresss.
     *      7. Done
     */

    static bool addr_taken[MAX_SLAVES];

    static void setup_i2c();
    static inline uint8_t addr_at_index(int i);
    static void daa_rescan();
    static bool daa_discover();
    static void daa_assign(pico_unique_board_id_t id);
    static uint8_t reserve_next_addr();
    static void echo(uint8_t slave_addr);

    // I2C pull-up resistor dynamic selection demux helper variables and functions.

    static uint8_t pullup_resistance_level;

    static void setup_pullup_demux();
    static void set_pullup_resistance_level(uint8_t value);
    static uint8_t adjust_pullup_resistance_level(int offset);
    static void apply_pullup_resistance_level();

    // PIO rise time measurement variables and functions.

    static PIO pio_hw;  // PIO hardware in use.
    static uint sm;     // PIO state machine number.

    static void nvic_pio_irq_handler();
    static void irq_handler_helper(int i);
    static void update_pullup_resistance_level(float avg_cycles);

    // -----------------------------------------------------------------------------------

    static void setup_i2c() {
      gpio_init(PICO_DEFAULT_I2C_SDA_PIN);
      gpio_init(PICO_DEFAULT_I2C_SCL_PIN);
      gpio_set_function(PICO_DEFAULT_I2C_SDA_PIN, GPIO_FUNC_I2C);
      gpio_set_function(PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C);
      if (INTERNAL_PULL_UP) {
        gpio_pull_up(PICO_DEFAULT_I2C_SDA_PIN);
        gpio_pull_up(PICO_DEFAULT_I2C_SCL_PIN);
      } else {
        gpio_disable_pulls(PICO_DEFAULT_I2C_SDA_PIN);
        gpio_disable_pulls(PICO_DEFAULT_I2C_SCL_PIN);
      }
      i2c_init(i2c0, BAUD_RATE);

      for (int i = 0; i < MAX_SLAVES; ++i) {
        addr_taken[i] = false;
      }
    }

    static inline uint8_t addr_at_index(int i) {
      return i + I2C_DEFAULT_SLAVE_ADDR + 1;
    }

    static void daa_rescan() {
      bool discover_done = false;
      while (!discover_done) {
        discover_done = !daa_discover();
      }
    }

    static bool daa_discover() {
      uint8_t command = COMMAND_DISCOVER;
      printf("here\n");
      int bytes_sent = i2c_write_blocking(i2c0, I2C_DEFAULT_SLAVE_ADDR, &command, 1, false);
      printf("Discover bytes sent: %d\n", bytes_sent);
      if (bytes_sent == 1) {
        // at least one slave device got the command
        pico_unique_board_id_t id;
        int bytes_recvd = i2c_read_blocking(i2c0, I2C_DEFAULT_SLAVE_ADDR, &id, sizeof(id), false);
        printf("Discover unique id size returned %d\n", bytes_recvd);
        daa_assign(id);
        return true;
      } else {
        return false;
      }
    }

    static void daa_assign(pico_unique_board_id_t id) {
      printf("assigning address for id %llx\n", *(uint64_t *)&id);
      uint8_t addr = reserve_next_addr();
      if (addr == (uint8_t)-1) {
        printf("assign: max address reached\n");
        return;
      }
      printf("Assigning %x as the new slave address\n", addr);

      // Format: [address reassignment command | unique identifier | new address]
      uint8_t buf[2 + sizeof(pico_unique_board_id_t)];
      buf[0] = COMMAND_ASSIGN;
      memcpy(buf + 1, &id, sizeof(id));
      buf[1 + sizeof(pico_unique_board_id_t)] = addr;

      int bytes_sent = i2c_write_blocking(i2c0, I2C_DEFAULT_SLAVE_ADDR, buf, sizeof(buf), false);
      printf("Assignment command bytes sent: %d\n", bytes_sent);

      // Echo device at new address to test connectivity.
      echo(addr);
    }

    static uint8_t reserve_next_addr() {
      int i = 0;
      while (addr_taken[i] && i < MAX_SLAVES) {
        ++i;
      }
      if (i == MAX_SLAVES) return -1;

      addr_taken[i] = true;
      return addr_at_index(i);
    }

    static void echo(uint8_t slave_addr) {
      static const char *const msg = "Master Sent!";
      uint8_t buf[32];
      buf[0] = COMMAND_ECHO;
      memcpy(buf, msg, strlen(msg) + 1);
      int bytes_sent = i2c_write_blocking(i2c0, slave_addr, msg, 2+strlen(msg), false);

      uint8_t recv[32] = {0};
      int bytes_read = i2c_read_blocking(i2c0, slave_addr, recv, 1+strlen(msg), false);
    }

    static void setup_pullup_demux() {
      gpio_init(PULLUP_DEMUX_A0_PIN);
      gpio_init(PULLUP_DEMUX_A1_PIN);
      gpio_set_dir(PULLUP_DEMUX_A0_PIN, GPIO_OUT);
      gpio_set_dir(PULLUP_DEMUX_A1_PIN, GPIO_OUT);
    }

    static void set_pullup_resistance_level(uint8_t value) {
      pullup_resistance_level = value;
      apply_pullup_resistance_level();
    }

    static uint8_t adjust_pullup_resistance_level(int offset) {
      pullup_resistance_level += offset;
      apply_pullup_resistance_level();
    }
    static void apply_pullup_resistance_level() {
      gpio_put(PULLUP_DEMUX_A0_PIN, pullup_resistance_level & 0b1);
      gpio_put(PULLUP_DEMUX_A1_PIN, pullup_resistance_level & 0b10);
    }

    static void nvic_pio_irq_handler() {
      static bool on = false;
      for (int i = 0; i < 4; ++i) {
        if (pio_interrupt_get(pio_hw, i)) {
          irq_handler_helper(i);
        }
      }
    }

    static void irq_handler_helper(int irq) {
      switch (irq) {
        case 0: {
          float avg_cycles = get_avg_cycles(pio_hw, sm, RISE_TIME_COUNT_LIMIT);
          printf("%f cycles\n", avg_cycles);
          update_pullup_resistance_level(avg_cycles);
          pio_sm_put_blocking(pio_hw, sm, RISE_TIME_COUNT_LIMIT - 1);
          break;
        }

        case 1:
          printf("resolution warning\n");
          break;

        case 2:
          printf("capacitance warning\n");
          break;

        default:
          printf("unknown irq flag warning\n");
          break;
      }
      pio_interrupt_clear(pio_hw, irq);
    }

    static void update_pullup_resistance_level(float avg_cycles) {
      if (avg_cycles < RISE_TIME_CYCLES_MIN && pullup_resistance_level < 3) {
        printf("Master: increasing pull up resistance (%d -> %d)\n",
                pullup_resistance_level, pullup_resistance_level + 1);
        adjust_pullup_resistance_level(1);
      } else if (avg_cycles > RISE_TIME_CYCLES_MAX && pullup_resistance_level > 0) {
        printf("Master: decreasing pull up resistance (%d -> %d)\n",
                pullup_resistance_level, pullup_resistance_level - 1);
        adjust_pullup_resistance_level(-1);
      }
    }
  =}

  timer echo_timer(3 s, 2 s)
  logical action initial_daa_scan

  reaction(startup) -> initial_daa_scan {=
    setup_i2c();
    setup_pullup_demux();
    set_pullup_resistance_level(3);

    rise_time_init(BAUD_RATE, PIO_LO_THRESHOLD_PIN, PIO_HI_THRESHOLD_PIN,
                   RISE_TIME_COUNT_LIMIT, &nvic_pio_irq_handler, &pio_hw, &sm);

    // Perform initial address allocation after a 10 second delay.
    // This is to allow time to launch terminal to monitor USB output messages.
    lf_schedule(initial_daa_scan, MSEC(10000));
  =}

  reaction(initial_daa_scan) {=
    daa_rescan();
  =}

  reaction(echo_timer) {=
    for (int i = 0; i < MAX_SLAVES; ++i) {
      if (addr_taken[i]) echo(addr_at_index(i));
    }
  =}
}
