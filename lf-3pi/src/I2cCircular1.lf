target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  threading: false,
  cmake-include: ["i2cslave.txt"]
}

preamble {=
  #include <stdio.h>
  #include <pico/stdlib.h>
  #include <hardware/gpio.h>
  #include <pico/binary_info.h>
  #include <hardware/i2c.h>
  #include <pico/i2c_slave.h>
  #include <string.h>

  #define ADDR 0x55
  #define PICO_DEFAULT_I2C_SDA_PIN 4
  #define PICO_DEFAULT_I2C_SCL_PIN 5
=}

main reactor {
  preamble {=
    static bool led = false;
    static bool received = false;
    static struct {
      uint8_t mem[32];
      uint8_t mem_address;
      bool mem_address_written;
    } context;

    static void i2c_slave_handler(i2c_inst_t *i2c, i2c_slave_event_t event) {
      switch (event) {
      case I2C_SLAVE_RECEIVE: // master has written some data
          if (!context.mem_address_written) {
              // writes always start with the memory address
              context.mem_address = i2c_read_byte_raw(i2c);
              context.mem_address_written = true;
          } else {
              // save into memory
              context.mem[context.mem_address] = i2c_read_byte_raw(i2c);
              context.mem_address++;

              led = !led;
              gpio_put(16, !led);
          }
          break;
      case I2C_SLAVE_REQUEST: // master is requesting data
          // load from memory
          i2c_write_byte_raw(i2c, context.mem[context.mem_address]);
          context.mem_address++;
          break;
      case I2C_SLAVE_FINISH: // master has signalled Stop / Restart
          context.mem_address_written = false;
          received = true;
          break;
      default:
          break;
      }
    }

    static void init() {
      gpio_init(PICO_DEFAULT_I2C_SDA_PIN);
      gpio_init(PICO_DEFAULT_I2C_SCL_PIN);
      gpio_set_function(PICO_DEFAULT_I2C_SDA_PIN, GPIO_FUNC_I2C);
      gpio_set_function(PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C);
      gpio_pull_up(PICO_DEFAULT_I2C_SDA_PIN);
      gpio_pull_up(PICO_DEFAULT_I2C_SCL_PIN);
      i2c_init(i2c0, 100);
    }

    static void run_as_slave() {
      i2c_slave_init(i2c0, ADDR, &i2c_slave_handler);
    }

    static void run_as_master() {
      i2c_slave_deinit(i2c0);
    }
  =}

  timer button(0, 100 ms)
  timer t(0, 100 ms)
  state master : bool = false

  reaction(startup) {=
    // I2C initialization
    init();
    run_as_slave();
    gpio_init(0);
    gpio_set_dir(0, GPIO_IN);
    gpio_init(16);
    gpio_set_dir(16, GPIO_OUT);
  =}

  reaction(button) {=
    // Scan button press
    if (!self->master && gpio_get(0)) {
      self->master = true;
      run_as_master();
    }
  =}

  reaction(t) {=
    static const char *const msg = "Master Sent!";
    if (self->master) {
      uint8_t buf[32];
      buf[0] = 0;
      memcpy(buf + 1, msg, strlen(msg));
      int written = i2c_write_blocking(i2c0, ADDR, buf, 1+strlen(msg), false);
      printf("bytes written: %d\n", written);
      self->master = false;
      run_as_slave();
    }
  =}

  // reaction(t2) {=
  //   uint8_t buf[1] = {0};
  //   uint8_t receive[32];
  //   i2c_write_blocking(i2c0, ADDR1, buf, 1, false);
  //   i2c_read_blocking(i2c0, ADDR1, receive, 12, false);
  //   receive[strlen(receive)] = '\0';
  //   printf("%s\n",receive);
  // =}
}
