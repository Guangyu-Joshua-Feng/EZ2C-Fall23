target C {
  compile-definitions: {
    EXECUTABLE_PREAMBLE: "",
    NUMBER_OF_FEDERATES: "2",
    FEDERATED: "",
    FEDERATED_CENTRALIZED: ""
  },
  _fed_setup: "include/_federate__p_preamble.h",
  cmake-include: "include/federate__p_extension.cmake",
  keepalive: true,
  threading: true
}


preamble {=
#ifdef __cplusplus
extern "C" {
#endif
#include "core/federated/federate.h"
#include "core/federated/net_common.h"
#include "core/federated/net_util.h"
#include "core/federated/clock-sync.h"
#include "core/threaded/reactor_threaded.h"
#include "core/utils/util.h"
extern federate_instance_t _fed;
#ifdef __cplusplus
}
#endif


=}

reactor Print {
  input in: int

  reaction(
      in) {=
    lf_print("Received: %d at (%lld, %d)", in->value,
        lf_time_logical_elapsed(), lf_tag().microstep
    );
  =}
}
reactor _pin {
  input port0: int

  output port: int

  port0 -> port
}
@_NetworkReactor(Receiver)
reactor NetworkReceiver_0 {
  output msg: int

  logical action networkMessage: int

  reaction(startup) {= self->_lf__reaction_1.is_an_input_reaction = true; =}

  reaction(networkMessage) -> msg {=
    msg->physical_time_of_arrival = self->_lf__networkMessage.physical_time_of_arrival;
    lf_set(msg, networkMessage->value);
  =}
}
@_fed_config()
main reactor  {

    p = new Print()
    
    
    
    
    
    
    @_tpoLevel(2)
    nr_federate__p = new NetworkReceiver_0()
    _pin0 = new _pin()
    _pin0.port -> p.in
    nr_federate__p.msg -> _pin0.port0
}
